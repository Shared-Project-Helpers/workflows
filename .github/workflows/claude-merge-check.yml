name: Claude Merge Readiness Check

on:
  workflow_call:
    inputs:
      model:
        description: 'Claude model to use'
        required: false
        default: 'claude-opus-4-6'
        type: string
      pr_number:
        description: 'Pull request number to check'
        required: true
        type: string
      checker_name:
        description: 'Display name for the merge readiness checker persona'
        required: false
        default: 'Balin'
        type: string
      app_id:
        description: 'GitHub App ID for custom bot identity (leave empty to use github-actions[bot])'
        required: false
        default: ''
        type: string
      required_reviewer_names:
        description: 'Comma-separated list of required reviewer persona names to check for approval (e.g. "Dwalin,Oin"). Matched against review comment bodies.'
        required: false
        default: ''
        type: string
      trigger_fix_on_behind:
        description: 'Trigger fix workflow when branch is behind base'
        required: false
        default: 'true'
        type: string
      fix_workflow_id:
        description: 'Fix workflow filename to dispatch for branch updates'
        required: false
        default: 'claude-fix.yml'
        type: string
    secrets:
      ANTHROPIC_API_KEY:
        required: true
      APP_PRIVATE_KEY:
        required: false
        description: 'GitHub App private key for custom bot identity'
    outputs:
      ready:
        description: 'Whether the PR is ready to merge (true/false)'
        value: ${{ jobs.check.outputs.ready }}
      blocking_issues:
        description: 'Number of blocking issues found'
        value: ${{ jobs.check.outputs.blocking_issues }}
      behind:
        description: 'Whether the PR branch is behind the base (true/false)'
        value: ${{ jobs.check.outputs.behind }}
      head_ref:
        description: 'PR head branch ref'
        value: ${{ jobs.check.outputs.head_ref }}

jobs:
  check:
    name: Merge Readiness Check
    runs-on: ubuntu-latest
    outputs:
      ready: ${{ steps.assess.outputs.ready }}
      blocking_issues: ${{ steps.assess.outputs.blocking_issues }}
      behind: ${{ steps.pr.outputs.behind }}
      head_ref: ${{ steps.pr.outputs.head_ref }}

    steps:
      - name: Get PR info
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ inputs.pr_number }};

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            core.setOutput('number', prNumber);
            core.setOutput('head_sha', pr.head.sha);
            core.setOutput('head_ref', pr.head.ref);
            core.setOutput('base_ref', pr.base.ref);
            core.setOutput('mergeable', pr.mergeable ?? 'unknown');
            core.setOutput('mergeable_state', pr.mergeable_state ?? 'unknown');
            core.setOutput('files_changed', pr.changed_files);
            core.setOutput('commits', pr.commits);
            core.setOutput('additions', pr.additions);
            core.setOutput('deletions', pr.deletions);
            core.setOutput('draft', pr.draft);
            core.setOutput('title', pr.title);
            core.setOutput('body', (pr.body || '').substring(0, 1000));

            // Check if branch is behind base
            const { data: comparison } = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: pr.head.sha,
              head: pr.base.ref
            });
            const behind = comparison.ahead_by > 0;
            core.setOutput('behind', String(behind));

      - name: Create check run on PR
        id: create-check
        uses: actions/github-script@v7
        with:
          script: |
            const { data: checkRun } = await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'Merge Readiness',
              head_sha: '${{ steps.pr.outputs.head_sha }}',
              status: 'in_progress',
              output: {
                title: 'Assessing merge readiness...',
                summary: 'Checking current CI and review status.'
              }
            });
            core.setOutput('check_run_id', checkRun.id);

      - name: Get CI check status
        id: checks
        uses: actions/github-script@v7
        with:
          script: |
            const { data: checks } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: '${{ steps.pr.outputs.head_sha }}'
            });

            // Exclude our own check runs from the assessment
            const ownName = 'Merge Readiness Check';
            const checkRuns = checks.check_runs
              .filter(check => !check.name.includes(ownName) && check.name !== 'Merge Readiness')
              .map(check => ({
                name: check.name,
                status: check.status,
                conclusion: check.conclusion
              }));

            const total = checkRuns.length;
            const successful = checkRuns.filter(c => c.conclusion === 'success').length;
            const failed = checkRuns.filter(c => c.conclusion === 'failure').length;
            const pending = checkRuns.filter(c => c.status !== 'completed').length;
            const skipped = checkRuns.filter(c => c.conclusion === 'skipped').length;

            const summary = {
              total,
              successful,
              failed,
              pending,
              skipped,
              all_passed: total > 0 && failed === 0 && pending === 0
            };

            core.setOutput('summary', JSON.stringify(summary));
            core.setOutput('details', JSON.stringify(checkRuns));

      - name: Get review status
        id: reviews
        uses: actions/github-script@v7
        with:
          script: |
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ steps.pr.outputs.number }}
            });

            // Get the most recent non-dismissed review from each reviewer
            // Exclude reviews from github-actions[bot] (our own bot reviews)
            const latestReviews = {};
            for (const review of reviews) {
              if (review.state === 'DISMISSED') continue;
              if (review.user.login === 'github-actions[bot]' || review.user.type === 'Bot') continue;
              const reviewer = review.user.login;
              latestReviews[reviewer] = review;
            }

            const states = Object.values(latestReviews).map(r => ({
              user: r.user.login,
              state: r.state
            }));

            const approved = states.filter(s => s.state === 'APPROVED').length;
            const changesRequested = states.filter(s => s.state === 'CHANGES_REQUESTED').length;

            // Check required reviewer approvals by matching persona names in review bodies
            const requiredNames = '${{ inputs.required_reviewer_names }}'.split(',').map(n => n.trim()).filter(Boolean);
            const requiredReviewerStatus = {};

            if (requiredNames.length > 0) {
              // Also check PR comments for reviewer personas
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ steps.pr.outputs.number }}
              });

              for (const name of requiredNames) {
                // Check formal reviews for persona name in body
                const formalApproval = reviews.some(r =>
                  r.state === 'APPROVED' && r.body && r.body.includes(name)
                );

                // Check comments for approval pattern (e.g., "Dwalin's Performance Review" with "APPROVE")
                const commentApproval = comments.some(c =>
                  c.body.includes(name) &&
                  c.body.includes('Review') &&
                  c.body.includes('**Decision:** APPROVE')
                );

                requiredReviewerStatus[name] = formalApproval || commentApproval ? 'approved' : 'pending';
              }
            }

            const allRequiredApproved = requiredNames.length === 0 ||
              Object.values(requiredReviewerStatus).every(s => s === 'approved');

            const summary = {
              total: states.length,
              approved,
              changes_requested: changesRequested,
              has_approvals: approved > 0,
              has_change_requests: changesRequested > 0,
              reviewers: states,
              required_reviewers: requiredReviewerStatus,
              all_required_approved: allRequiredApproved
            };

            core.setOutput('summary', JSON.stringify(summary));

            // Write to file for later steps to read safely
            const fs = require('fs');
            fs.writeFileSync('reviews_summary.json', JSON.stringify(summary));

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Assess merge readiness
        id: assess
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          MODEL: ${{ inputs.model }}
          PR_TITLE: ${{ steps.pr.outputs.title }}
          PR_BODY: ${{ steps.pr.outputs.body }}
          PR_DRAFT: ${{ steps.pr.outputs.draft }}
          PR_MERGEABLE: ${{ steps.pr.outputs.mergeable }}
          PR_MERGEABLE_STATE: ${{ steps.pr.outputs.mergeable_state }}
          PR_FILES_CHANGED: ${{ steps.pr.outputs.files_changed }}
          PR_COMMITS: ${{ steps.pr.outputs.commits }}
          PR_ADDITIONS: ${{ steps.pr.outputs.additions }}
          PR_DELETIONS: ${{ steps.pr.outputs.deletions }}
          CHECKS_SUMMARY: ${{ steps.checks.outputs.summary }}
          CHECKS_DETAILS: ${{ steps.checks.outputs.details }}
          REVIEWS_SUMMARY: ${{ steps.reviews.outputs.summary }}
          CHECKER_NAME: ${{ inputs.checker_name }}
          REQUIRED_REVIEWER_NAMES: ${{ inputs.required_reviewer_names }}
        run: |
          pip install anthropic
          python << 'PYTHON_SCRIPT'
          import anthropic
          import os
          import json
          import re

          client = anthropic.Anthropic()

          pr_title = os.environ.get('PR_TITLE', '')
          pr_body = os.environ.get('PR_BODY', '')
          pr_draft = os.environ.get('PR_DRAFT', 'false') == 'true'
          pr_mergeable = os.environ.get('PR_MERGEABLE', 'unknown')
          pr_mergeable_state = os.environ.get('PR_MERGEABLE_STATE', 'unknown')
          pr_files = os.environ.get('PR_FILES_CHANGED', '0')
          pr_commits = os.environ.get('PR_COMMITS', '0')
          pr_additions = os.environ.get('PR_ADDITIONS', '0')
          pr_deletions = os.environ.get('PR_DELETIONS', '0')
          checks_summary = json.loads(os.environ.get('CHECKS_SUMMARY', '{}'))
          checks_details = json.loads(os.environ.get('CHECKS_DETAILS', '[]'))
          reviews_summary = json.loads(os.environ.get('REVIEWS_SUMMARY', '{}'))
          model = os.environ.get('MODEL', 'claude-opus-4-6')
          checker_name = os.environ.get('CHECKER_NAME', 'Balin')

          required_reviewer_names = os.environ.get('REQUIRED_REVIEWER_NAMES', '')

          required_section = ""
          if required_reviewer_names:
              required_section = f"""
          5. Have all required specialized reviewers approved? The required reviewers are: {required_reviewer_names}
             Check the "required_reviewers" field in the reviews data â€” all must show "approved".
             If any show "pending", that reviewer has not yet approved and the PR is NOT ready."""

          prompt = f"""You are {checker_name}, a merge readiness assessment agent. You are wise and practical,
          providing clear assessments of whether a pull request is ready to merge.

          ## PR Details
          - **Title**: {pr_title}
          - **Draft**: {pr_draft}
          - **Files Changed**: {pr_files}
          - **Commits**: {pr_commits}
          - **Lines**: +{pr_additions} -{pr_deletions}
          - **Mergeable**: {pr_mergeable}
          - **Mergeable State**: {pr_mergeable_state}

          ## CI Checks
          {json.dumps(checks_summary, indent=2)}

          Check details:
          {json.dumps(checks_details[:15], indent=2)}

          ## Reviews
          {json.dumps(reviews_summary, indent=2)}

          ## PR Description
          {pr_body[:800]}

          ## Task
          Assess merge readiness. You are one of the required reviewers â€” your approval is handled
          separately, so do NOT consider whether there are other approving reviews. Only assess:
          1. Are all CI checks passing? (failed or pending = not ready)
          2. Are there outstanding change requests from human reviewers? (bot reviews are excluded)
          3. Are there merge conflicts? (mergeable=false or mergeable_state=dirty)
          4. Is this a draft?
          {required_section}

          ## IMPORTANT: Summary Requirements
          Your summary MUST be a bullet-point list, one bullet per check performed.
          Each bullet should state the check name, its result, and a brief detail. For example:
          - **CI Status:** PASS â€” 5/5 checks succeeded, 1 skipped (Apple Client)
          - **Merge Conflicts:** PASS â€” no conflicts detected (mergeable=true)
          - **Draft Status:** PASS â€” PR is not a draft
          - **Change Requests:** PASS â€” no human reviewers have requested changes
          - **Conclusion:** Ready to merge â€” all gates passed

          Use this exact bullet format. Do NOT write paragraphs. End with a Conclusion bullet
          that states whether the PR is ready and why.
          This summary will be posted as a comment on the PR, so make it clear and scannable.

          Respond with JSON:
          {{
            "ready": true or false,
            "confidence": "high" | "medium" | "low",
            "summary": "Bullet-point list of checks and conclusion (use markdown bullet format with - prefix)",
            "checks": {{
              "ci_passing": true/false,
              "no_merge_conflicts": true/false,
              "not_draft": true/false,
              "no_change_requests": true/false,
              "required_reviewers_approved": true/false
            }},
            "blocking_issues": ["list of blockers, empty if ready"],
            "warnings": ["non-blocking concerns, optional"]
          }}

          Be direct and thorough. Explain your reasoning for each check result.
          """

          response = client.messages.create(
              model=model,
              max_tokens=2048,
              messages=[{"role": "user", "content": prompt}]
          )

          result = response.content[0].text

          try:
              json_match = re.search(r'\{[\s\S]*\}', result)
              if json_match:
                  assessment = json.loads(json_match.group())
              else:
                  assessment = {"ready": False, "confidence": "low", "summary": "Could not parse assessment", "checks": {}, "blocking_issues": ["Assessment parsing failed"], "warnings": []}
          except Exception as e:
              print(f"Error parsing response: {e}")
              assessment = {"ready": False, "confidence": "low", "summary": "Could not parse assessment", "checks": {}, "blocking_issues": ["Assessment parsing failed"], "warnings": []}

          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"ready={str(assessment.get('ready', False)).lower()}\n")
              f.write(f"blocking_issues={len(assessment.get('blocking_issues', []))}\n")

          with open('assessment_result.json', 'w') as f:
              json.dump(assessment, f)

          print(json.dumps(assessment, indent=2))
          PYTHON_SCRIPT

      - name: Generate app token
        id: app-token
        if: inputs.app_id != ''
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ inputs.app_id }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Post assessment comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || github.token }}
          script: |
            const fs = require('fs');
            const assessment = JSON.parse(fs.readFileSync('assessment_result.json', 'utf8'));
            const checkerName = '${{ inputs.checker_name }}';

            const statusEmoji = assessment.ready ? 'âœ…' : 'â›”';
            const confidenceEmoji = { high: 'ðŸ”µ', medium: 'ðŸŸ¡', low: 'ðŸ”´' }[assessment.confidence] || 'âšª';

            let body = `## ${statusEmoji} ${checkerName}'s Merge Readiness Assessment\n\n`;
            body += `**Status:** ${assessment.ready ? 'Ready to merge' : 'Not ready'} (${confidenceEmoji} ${assessment.confidence} confidence)\n\n`;
            body += `### Summary\n${assessment.summary}\n\n`;

            body += `### Readiness Checklist\n`;
            const checks = assessment.checks || {};
            const checkItems = [
              { key: 'ci_passing', label: 'All CI checks passing' },
              { key: 'no_change_requests', label: 'No outstanding change requests' },
              { key: 'no_merge_conflicts', label: 'No merge conflicts' },
              { key: 'not_draft', label: 'Not a draft PR' },
              { key: 'required_reviewers_approved', label: 'All required reviewers approved' }
            ];

            for (const item of checkItems) {
              const passed = checks[item.key];
              const status = passed === true ? 'âœ…' : passed === false ? 'âŒ' : 'â“';
              body += `- ${status} ${item.label}\n`;
            }

            // Show required reviewer status if configured
            const requiredReviewers = '${{ inputs.required_reviewer_names }}'.split(',').map(n => n.trim()).filter(Boolean);
            if (requiredReviewers.length > 0) {
              body += `\n### Required Reviewer Approvals\n`;
              try {
                const reviewsSummary = JSON.parse(fs.readFileSync('reviews_summary.json', 'utf8'));
                const reqStatus = reviewsSummary.required_reviewers || {};
                for (const name of requiredReviewers) {
                  const status = reqStatus[name] === 'approved' ? 'âœ…' : 'â³';
                  body += `- ${status} ${name}\n`;
                }
              } catch (e) {
                for (const name of requiredReviewers) {
                  body += `- â“ ${name}\n`;
                }
              }
            }

            if (assessment.blocking_issues && assessment.blocking_issues.length > 0) {
              body += `\n### Blocking Issues\n`;
              for (const issue of assessment.blocking_issues) {
                body += `- ${issue}\n`;
              }
            }

            if (assessment.warnings && assessment.warnings.length > 0) {
              body += `\n### Warnings\n`;
              for (const warning of assessment.warnings) {
                body += `- ${warning}\n`;
              }
            }

            body += `\n### Conclusion\n`;
            if (assessment.ready) {
              body += `**This PR is ready to merge.** All checks passed â€” CI is green, no merge conflicts, no outstanding human change requests, and the PR is not a draft.\n`;
            } else {
              body += `**This PR is not yet ready to merge.** Resolve the blocking issues listed above before merging.\n`;
            }

            body += `\n### PR Stats\n`;
            body += `| Files | Commits | Lines |\n|-------|---------|-------|\n`;
            body += `| ${{ steps.pr.outputs.files_changed }} | ${{ steps.pr.outputs.commits }} | +${{ steps.pr.outputs.additions }} -${{ steps.pr.outputs.deletions }} |\n`;

            const prUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${{ steps.pr.outputs.number }}`;
            body += `\n---\n*Assessment by ${checkerName}*\n\n**PR:** ${prUrl}`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.pr.outputs.number }},
              body: body
            });

      - name: Submit formal review
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || github.token }}
          script: |
            const fs = require('fs');
            const assessment = JSON.parse(fs.readFileSync('assessment_result.json', 'utf8'));
            const checkerName = '${{ inputs.checker_name }}';
            const event = assessment.ready ? 'APPROVE' : 'REQUEST_CHANGES';
            const reviewBody = assessment.ready
              ? `${checkerName} approves: ${assessment.summary}`
              : `${checkerName} blocks merge: ${assessment.summary}`;

            try {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: ${{ steps.pr.outputs.number }},
                event: event,
                body: reviewBody
              });
              console.log(`Submitted ${event} review.`);
            } catch (error) {
              console.log(`Could not submit formal review: ${error.message}`);
            }

      - name: Update check run with result
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let conclusion = 'failure';
            let title = 'Assessment failed';
            let summary = 'Could not complete merge readiness assessment.';

            try {
              const assessment = JSON.parse(fs.readFileSync('assessment_result.json', 'utf8'));
              conclusion = assessment.ready ? 'success' : 'failure';
              title = assessment.ready ? 'Ready to merge' : 'Not ready to merge';
              summary = assessment.summary || summary;
              if (assessment.blocking_issues && assessment.blocking_issues.length > 0) {
                summary += '\n\nBlocking issues:\n' + assessment.blocking_issues.map(i => `- ${i}`).join('\n');
              }
            } catch (e) {
              console.log('Could not read assessment result:', e.message);
            }

            await github.rest.checks.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: ${{ steps.create-check.outputs.check_run_id }},
              status: 'completed',
              conclusion: conclusion,
              output: {
                title: title,
                summary: summary
              }
            });

      - name: Trigger fix workflow to update branch
        if: steps.pr.outputs.behind == 'true' && inputs.trigger_fix_on_behind == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: '${{ inputs.fix_workflow_id }}',
              ref: '${{ steps.pr.outputs.head_ref }}',
              inputs: {
                pr_number: '${{ inputs.pr_number }}'
              }
            });
