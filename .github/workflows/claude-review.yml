name: Claude Code Review

on:
  workflow_call:
    inputs:
      model:
        description: 'Claude model to use'
        required: false
        default: 'claude-opus-4-6'
        type: string
      review_guidelines:
        description: 'Additional review guidelines (appended to defaults)'
        required: false
        default: ''
        type: string
      diff_limit:
        description: 'Max diff size in bytes'
        required: false
        default: '50000'
        type: string
      excluded_files:
        description: 'Git pathspec for excluded files'
        required: false
        default: ':!*.lock :!package-lock.json'
        type: string
      auto_merge_label:
        description: 'Label that enables auto-merge on approval (empty = disabled)'
        required: false
        default: ''
        type: string
      auto_merge_method:
        description: 'Merge method when auto-merging (merge, squash, rebase)'
        required: false
        default: 'squash'
        type: string
      reviewer_name:
        description: 'Display name for the code reviewer persona'
        required: false
        default: 'Claude'
        type: string
      app_id:
        description: 'GitHub App ID for custom bot identity (leave empty to use github-actions[bot])'
        required: false
        default: ''
        type: string
      trigger_fix_on_request_changes:
        description: 'Trigger fix workflow when review requests changes'
        required: false
        default: 'true'
        type: string
      trigger_merge_check_on_approve:
        description: 'Trigger merge check workflow when review approves'
        required: false
        default: 'true'
        type: string
      fix_workflow_id:
        description: 'Fix workflow filename to dispatch'
        required: false
        default: 'claude-fix.yml'
        type: string
      merge_check_workflow_id:
        description: 'Merge check workflow filename to dispatch'
        required: false
        default: 'claude-merge-check.yml'
        type: string
      create_tracked_issues:
        description: 'Create GitHub Issues for non-blocking (tracked) concerns'
        required: false
        default: 'true'
        type: string
    secrets:
      ANTHROPIC_API_KEY:
        required: true
      APP_PRIVATE_KEY:
        required: false
        description: 'GitHub App private key for custom bot identity'
    outputs:
      decision:
        description: 'Review decision (APPROVE, REQUEST_CHANGES, or COMMENT)'
        value: ${{ jobs.review.outputs.decision }}
      pr_number:
        description: 'Pull request number'
        value: ${{ jobs.review.outputs.pr_number }}
      head_ref:
        description: 'PR head branch ref'
        value: ${{ jobs.review.outputs.head_ref }}

jobs:
  review:
    name: Code Review
    runs-on: ubuntu-latest
    outputs:
      decision: ${{ steps.review.outputs.decision }}
      pr_number: ${{ steps.pr.outputs.number }}
      head_ref: ${{ steps.pr.outputs.head_ref }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.ref || github.head_ref }}

      - name: Get PR info
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            let prNumber, baseSha, headSha;

            let headRef;

            if (context.eventName === 'pull_request' || context.eventName === 'pull_request_target') {
              prNumber = context.payload.pull_request.number;
              baseSha = context.payload.pull_request.base.sha;
              headSha = context.payload.pull_request.head.sha;
              headRef = context.payload.pull_request.head.ref;
            } else {
              prNumber = context.payload.issue.number;
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              baseSha = pr.base.sha;
              headSha = pr.head.sha;
              headRef = pr.head.ref;
            }

            core.setOutput('number', prNumber);
            core.setOutput('base_sha', baseSha);
            core.setOutput('head_sha', headSha);
            core.setOutput('head_ref', headRef);

      - name: Get diff
        id: diff
        run: |
          DELIMITER="DIFF_$(openssl rand -hex 16)"
          echo "diff<<${DELIMITER}" >> $GITHUB_OUTPUT
          git diff ${{ steps.pr.outputs.base_sha }}..${{ steps.pr.outputs.head_sha }} -- . ${{ inputs.excluded_files }} | head -c ${{ inputs.diff_limit }} >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "${DELIMITER}" >> $GITHUB_OUTPUT

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Review with Claude
        id: review
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          PR_DIFF: ${{ steps.diff.outputs.diff }}
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          MODEL: ${{ inputs.model }}
          EXTRA_GUIDELINES: ${{ inputs.review_guidelines }}
        run: |
          pip install anthropic
          python << 'PYTHON_SCRIPT'
          import anthropic
          import os
          import json
          import re

          client = anthropic.Anthropic()

          diff = os.environ.get('PR_DIFF', '')
          pr_number = os.environ.get('PR_NUMBER', '')
          model = os.environ.get('MODEL', 'claude-opus-4-6')
          extra_guidelines = os.environ.get('EXTRA_GUIDELINES', '')

          extra_section = f"\n\n## Project-Specific Guidelines\n{extra_guidelines}" if extra_guidelines else ""

          prompt = f"""You are a senior code reviewer. Review this pull request diff and provide feedback.

          ## Review Scope — IMPORTANT

          Your review is strictly limited to **implementation issues** — problems in the code as written.
          You MUST categorize every issue into one of two categories:

          ### BLOCKING issues (these prevent merging)
          Only flag as blocking if the issue is a concrete implementation problem:
          - Bugs, logic errors, off-by-one errors
          - Security vulnerabilities (SQL injection, XSS, credential leaks, etc.)
          - Race conditions or data corruption risks
          - Missing error handling that will cause crashes
          - Broken API contracts (wrong types, missing fields)
          - Performance issues that will cause real problems (N+1 queries, unbounded memory)

          ### TRACKED issues (noted but do NOT prevent merging)
          These are valid observations but should be filed as GitHub Issues for future work:
          - Architecture or design concerns
          - Code duplication / DRY violations
          - Missing tests (unless the untested code is clearly buggy)
          - Refactoring suggestions
          - Documentation gaps
          - Migration tooling or deployment concerns
          - Style or convention preferences
          - "Nice to have" improvements
          {extra_section}

          ## Decision Rules
          - **APPROVE** if there are zero blocking issues (even if there are tracked issues)
          - **REQUEST_CHANGES** only if there are one or more blocking issues

          ## Response Format
          Respond with a JSON object:
          {{
            "decision": "APPROVE" | "REQUEST_CHANGES",
            "summary": "Brief summary of the review",
            "blocking_issues": [
              {{
                "severity": "critical" | "major",
                "file": "path/to/file",
                "line": 42,
                "description": "Description of the implementation problem",
                "suggestion": "How to fix it"
              }}
            ],
            "tracked_issues": [
              {{
                "severity": "minor" | "suggestion",
                "title": "Short issue title for GitHub Issue",
                "file": "path/to/file",
                "line": 42,
                "description": "Description of the concern",
                "suggestion": "Recommended approach for future work"
              }}
            ]
          }}

          Remember: APPROVE when there are no blocking issues. Tracked issues will be
          automatically filed as GitHub Issues — they do NOT block the merge.

          ## Diff
          ```diff
          {diff[:40000]}
          ```
          """

          response = client.messages.create(
              model=model,
              max_tokens=4096,
              messages=[{"role": "user", "content": prompt}]
          )

          result = response.content[0].text

          # Try to extract JSON from the response
          try:
              json_match = re.search(r'\{[\s\S]*\}', result)
              if json_match:
                  review_data = json.loads(json_match.group())
              else:
                  review_data = {"decision": "APPROVE", "summary": result, "blocking_issues": [], "tracked_issues": []}
          except:
              review_data = {"decision": "APPROVE", "summary": result, "blocking_issues": [], "tracked_issues": []}

          # Normalize: ensure both issue lists exist
          review_data.setdefault('blocking_issues', [])
          review_data.setdefault('tracked_issues', [])

          # Also support legacy 'issues' key — migrate to tracked
          if 'issues' in review_data and not review_data['blocking_issues'] and not review_data['tracked_issues']:
              for issue in review_data.get('issues', []):
                  if issue.get('severity') in ('critical', 'major'):
                      review_data['blocking_issues'].append(issue)
                  else:
                      review_data['tracked_issues'].append(issue)

          # Enforce decision rules: only REQUEST_CHANGES if there are blocking issues
          if not review_data['blocking_issues']:
              review_data['decision'] = 'APPROVE'

          # Write outputs
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"decision={review_data.get('decision', 'APPROVE')}\n")
              f.write(f"summary={review_data.get('summary', 'Review completed')[:500]}\n")
              f.write(f"tracked_count={len(review_data.get('tracked_issues', []))}\n")
              f.write(f"blocking_count={len(review_data.get('blocking_issues', []))}\n")

          with open('review_result.json', 'w') as f:
              json.dump(review_data, f)

          print(json.dumps(review_data, indent=2))
          PYTHON_SCRIPT

      - name: Generate app token
        id: app-token
        if: inputs.app_id != ''
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ inputs.app_id }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Post review comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || github.token }}
          script: |
            const fs = require('fs');
            const reviewData = JSON.parse(fs.readFileSync('review_result.json', 'utf8'));

            const reviewerName = '${{ inputs.reviewer_name }}';
            const decision = reviewData.decision;
            const blockingIssues = reviewData.blocking_issues || [];
            const trackedIssues = reviewData.tracked_issues || [];

            let body = `## ${reviewerName}'s Code Review\n\n`;
            body += `**Decision:** ${decision}`;
            if (decision === 'APPROVE' && trackedIssues.length > 0) {
              body += ` (${trackedIssues.length} non-blocking concern${trackedIssues.length === 1 ? '' : 's'} filed as Issues)`;
            }
            body += `\n\n`;
            body += `### Summary\n${reviewData.summary}\n\n`;

            if (blockingIssues.length > 0) {
              body += `### Blocking Issues (must fix before merge)\n\n`;
              for (const issue of blockingIssues) {
                const emoji = issue.severity === 'critical' ? '\u{1F534}' : '\u{1F7E0}';
                body += `${emoji} **${(issue.severity || 'major').toUpperCase()}** `;
                if (issue.file) body += `in \`${issue.file}\``;
                if (issue.line) body += ` (line ${issue.line})`;
                body += `\n`;
                body += `> ${issue.description}\n`;
                if (issue.suggestion) {
                  body += `\n**Suggestion:** ${issue.suggestion}\n`;
                }
                body += `\n`;
              }
            }

            if (trackedIssues.length > 0) {
              body += `### Tracked Issues (filed as GitHub Issues)\n\n`;
              body += `These concerns have been filed as GitHub Issues for future work and do not block this PR.\n\n`;
              for (const issue of trackedIssues) {
                const emoji = issue.severity === 'minor' ? '\u{1F7E1}' : '\u{1F4A1}';
                body += `${emoji} **${(issue.severity || 'suggestion').toUpperCase()}** `;
                if (issue.title) body += `— ${issue.title} `;
                if (issue.file) body += `in \`${issue.file}\``;
                if (issue.line) body += ` (line ${issue.line})`;
                body += `\n`;
                body += `> ${issue.description}\n\n`;
              }
            }

            if (blockingIssues.length === 0 && trackedIssues.length === 0) {
              body += `No issues found. Code looks good!\n\n`;
            }

            const prUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${{ steps.pr.outputs.number }}`;
            body += `\n---\n*Reviewed by ${reviewerName}*\n\n**PR:** ${prUrl}`;

            // Post comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.pr.outputs.number }},
              body: body
            });

            // Submit formal review
            if (decision === 'APPROVE' || decision === 'REQUEST_CHANGES') {
              try {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: ${{ steps.pr.outputs.number }},
                  event: decision,
                  body: reviewData.summary
                });
              } catch (error) {
                console.log(`Note: Could not submit formal review (${error.message}). The review comment was posted successfully.`);
              }
            }

      - name: Create GitHub Issues for tracked concerns
        if: steps.review.outputs.tracked_count != '0' && inputs.create_tracked_issues == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || github.token }}
          script: |
            const fs = require('fs');
            const reviewData = JSON.parse(fs.readFileSync('review_result.json', 'utf8'));
            const trackedIssues = reviewData.tracked_issues || [];
            const prNumber = ${{ steps.pr.outputs.number }};
            const reviewerName = '${{ inputs.reviewer_name }}';

            const createdIssues = [];

            for (const issue of trackedIssues) {
              const title = issue.title || issue.description.substring(0, 80);
              let issueBody = `## Code Review Finding\n\n`;
              issueBody += `Identified during review of PR #${prNumber}.\n\n`;
              issueBody += `**Severity:** ${issue.severity || 'suggestion'}\n`;
              if (issue.file) issueBody += `**File:** \`${issue.file}\``;
              if (issue.line) issueBody += ` (line ${issue.line})`;
              if (issue.file) issueBody += `\n`;
              issueBody += `\n### Description\n${issue.description}\n`;
              if (issue.suggestion) {
                issueBody += `\n### Suggested Approach\n${issue.suggestion}\n`;
              }
              issueBody += `\n---\n*Filed automatically by ${reviewerName} code review from PR #${prNumber}*`;

              try {
                const { data: created } = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `[Review] ${title}`,
                  body: issueBody,
                  labels: ['code-review', 'tracked']
                });
                createdIssues.push({ number: created.number, title: created.title });
                console.log(`Created issue #${created.number}: ${created.title}`);
              } catch (error) {
                console.log(`Failed to create issue for: ${title} — ${error.message}`);
              }
            }

            // Post a summary comment linking to the created issues
            if (createdIssues.length > 0) {
              let body = `### Tracked Issues Created\n\n`;
              body += `The following GitHub Issues were created for non-blocking concerns from this review:\n\n`;
              for (const issue of createdIssues) {
                body += `- #${issue.number}: ${issue.title}\n`;
              }
              body += `\nThese do not block merging this PR.\n`;

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: body
              });
            }

      - name: Auto-merge if approved and labeled
        if: steps.review.outputs.decision == 'APPROVE' && inputs.auto_merge_label != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || github.token }}
          script: |
            const prNumber = ${{ steps.pr.outputs.number }};
            const autoMergeLabel = '${{ inputs.auto_merge_label }}';
            const mergeMethod = '${{ inputs.auto_merge_method }}';

            // Get PR details including labels
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            const hasAutoMergeLabel = pr.labels.some(label => label.name === autoMergeLabel);

            if (!hasAutoMergeLabel) {
              console.log(`PR does not have '${autoMergeLabel}' label. Skipping auto-merge.`);
              return;
            }

            console.log(`PR has '${autoMergeLabel}' label. Attempting auto-merge...`);

            try {
              // Enable auto-merge (GitHub will merge when all requirements are met)
              await github.graphql(`
                mutation($pullRequestId: ID!, $mergeMethod: PullRequestMergeMethod!) {
                  enablePullRequestAutoMerge(input: {
                    pullRequestId: $pullRequestId,
                    mergeMethod: $mergeMethod
                  }) {
                    pullRequest {
                      autoMergeRequest {
                        enabledAt
                      }
                    }
                  }
                }
              `, {
                pullRequestId: pr.node_id,
                mergeMethod: mergeMethod.toUpperCase()
              });

              console.log('Auto-merge enabled successfully.');

              // Post comment about auto-merge
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `\u{1F916} **Auto-merge enabled.** This PR will be merged automatically when all required checks pass.`
              });
            } catch (error) {
              console.log(`Could not enable auto-merge: ${error.message}`);
              // Fallback: try direct merge if auto-merge not available
              try {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  merge_method: mergeMethod
                });
                console.log('PR merged directly.');
              } catch (mergeError) {
                console.log(`Could not merge PR: ${mergeError.message}`);
              }
            }

      - name: Trigger fix workflow
        if: steps.review.outputs.decision == 'REQUEST_CHANGES' && inputs.trigger_fix_on_request_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: '${{ inputs.fix_workflow_id }}',
              ref: '${{ steps.pr.outputs.head_ref }}',
              inputs: {
                pr_number: '${{ steps.pr.outputs.number }}'
              }
            });

      - name: Trigger merge check workflow
        if: steps.review.outputs.decision == 'APPROVE' && inputs.trigger_merge_check_on_approve == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: '${{ inputs.merge_check_workflow_id }}',
              ref: 'main',
              inputs: {
                pr_number: '${{ steps.pr.outputs.number }}'
              }
            });
